1.1 Types and their supported opperations.

С++ статически типизированный язык

Integral types:
int
long 
long long 
short
char
bool(?)

Про каждый из типов можно сказать unsigned/signed

Есть типы со стандартизованной шириной например: int32_t (8, 16, 64)
Есть ещё std::byte, чтобы не класть всё в чары

Floating point types:
float
double
long double

Ещё есть тип size_t. Это специальный беззнаковый целочисленный тип который достаточен чтобы индексировать любую ячейку оперативной памяти.  

std::string s = "abc"
Что умеют делать строки?

operator \[](size_t ) // В индексе = длине строки гарантируется что лежит символ с кодом 0 для совместимости с Си, где были null-terminated strings, последний элемент в которых всегда равнялся символу с кодом 0
Почему например у строки s, доступ по индексу 4 это неопределённое поведение? Для ускорения, эффективность дороже безопасности 

.at(size_t) то же самое как скобочки только есть проверка за выход строки 

\+ += 
push_back(char), pop_back();


std::vector в целом как и строка, только нельзя складывать
Доступ по индексу понято работает за O(1), но за сколько работает push_back pop_back()? Амортизированное O(1), это значит что в среднем если вы много раз будете делать push_back, то время затраченное поделённое на количество раз будет стремиться к единице, но при этом каждый push_back отдельно может работать долго в худшем за линейное время 

Есть shrink_to_fit() чтобы уменьшить capacity по длине массива.

Clear() не освобождает память.


std::forward_list, std::list, std::deque (двусторонняя очередь), std::stack, std::queue, std::priority_queue


Ассоциативные контейнеры:
std::map<std::string, int> // Хранит упорядоченно, элементы лежат в порядке возрастания(?)

operator \[](Key) // Если такого ключа нет, то зарегистрирует его и вернёт значение по умолчанию
at(Key) // кинет исключение
Работают они за log(N) потому что элементы в порядке возрастания лежат
find(Key)
insert(Key), erase(Key)


std::set() 


Есть ещё все эти структуры с припиской unordered, где хранит их неупорядоченно, но вставка и удаление в среднем за O(1) (не амортизированное потому что асимптотика зависит не от количества операций, где за большое количество испытаний будет хорошая асимптотика, а асимптотика зависит от данных)


std::cout <<  Это тоже тип, по сути это глобальная операция для std::istream, std::outstream