Declararions definitions and scopes. 

```C++
#include <iostream>
#include <vector>
int a = 5;

void f(int x);

class C;
struct S;
enum E;
union U;

namespace N {
	int x;
	// Нельзя просто объявить, нужно сразу иницализировать
}

namespace N { 
	int y;
	// Можно такой же объявлять
}

int main() {
	using vi = std::vector<int>;
	return 0;
}
```
В глобальной области видимости, при объявлении переменной без инициализации она заполнится нулём, в локальных это не так.



```C++
int x = -1000;
int main() {
	int x = 0;
	for(int i = 0; i < 10; ++i) {
		int x = i;
		//...
		// Приоритет отдаётся переменной x в этой области видимости
		// достучаться до x в main нельзя, но можно было бы достучаться
			// до x в глобальной области видимости: ::x = -1001; 
	}


	int a = a; // То же самое как int a; :)
	
	return 0;
}
```


One difinition rule - каждая используемая сущность в программе должна быть определена. Использование функции которая объявлена но не определена - это ошибка стадии линковки. 
Для классов так, классы можно определить несколько раз, если все объявления дословоно идентичны, т.е:
```C++
void f(int a);
void f(int a);
// Но определить можно только один раз
void f(int a) {

}


```

Statement:
1.1) declarations
1.2) expressions
1.3) control statement // if, while... 

Expressions and operators.
По сути, программа на плюсах - последовательность объявлений.
Если declaration можно было писать в глобальном scope, то в локальном ещё есть expression.
Неформально, expression - набор переменных соединённых операторами
x + 5;
std::cout << x;

+
-
*
/
%
\>
<
<<
\>>
<=
\>=
|
&
^
&&
||
\==
!=
<=> // since c++ 20


v.size() >= 5 && v\[4] == true; // Стандартом гарантируется что выражение слева выполнится раньше справа и выражение справа не выполнится в случае если выражение слева ложно

(x = y) = z // То же самое что в x положить z;
l-value r-value на интуитивном уровне:
Каждое выражение относится  либо к r-value либо к l-value. Очень не строго и далеко не всегда так, но можно считать что l-value это то к чему можно что-либо присвоить, а r-value - наоборот. 